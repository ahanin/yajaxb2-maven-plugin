<faqs id="FAQ" title="Frequently Asked Questions">
    <part id="XJC">
        <title>XJC</title>
        <faq id="Multiple">
            <question>I have different schemas and want different packages for those schemas, how do I do this?</question>
            <answer>
                <p>You want to create multiple executions in your plugin declaration. This will allow you
                to have multiple configuration declarations and you can specify the schema and package to
                be run for that execution. In your configuration, you will need to have a different staleFile
                for each execution, so it will be able to determine if the xjc needs to be executed.</p>

                <p>An example is given on the XJC usage page.</p>
            </answer>
        </faq>
    </part>

    <part id="Schemagen">
        <title>Schemagen</title>
        <faq id="Tooling">
            <question>What tool is used by the jaxb2-maven-plugin to generate the XML schema definition files?</question>
            <answer>
                <p>The tool is called <i>SchemaGenerator</i>, and is part of the Java platform.
                (c.f. <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/schemagen.html">this documentation</a>).</p>

                <p>The jaxb2-maven-plugin provides some augmentations to the generated schema files, such
                as the ability to define a schema prefix and filename for each generated XML schema.</p>
            </answer>
        </faq>
        <faq id="SeveralGeneratedSchemaFiles">
            <question>How do generated XML schema files correlate to annotated java files?</question>
            <answer>
                <p>The SchemaGenerator tool generates one XML schema file <i>per XML namespace</i> it finds within
                the compilation unit (i.e. all annotated Java files selected for XML schema compilation).</p>

                <p>The correlation between java files and generated XML schema files is therefore only indirect;
                a single generated XML schema file can hold the result of annotations within several java files - and
                a single annotated java source file can give rise to definitions scattered over several XML
                schema files.</p>

                 <p>An example is given on the usage page for the schemagen goal.</p>
            </answer>
        </faq>

        <faq id="Example">
            <question>How can I annotate my java classes to generate XML schema?</question>
            <answer>
                <p>For the full example (including generated XML Schema definitions), please refer to the
                schemagen usage page. Provided below are screenshots of two annotated source files, and a
                constants definition interface.</p>

                <p><strong>Namespaces definition interface</strong>. Simply defines constants for the
                three namespaces used within the two classes below. <br/>
                <source>package se.west.schema;

public interface Namespaces {

    public static final String SOME_NAMESPACE = "http://some/namespace";
    public static final String ANOTHER_NAMESPACE = "http://another/namespace";
    public static final String YET_ANOTHER_NAMESPACE = "http://yet/another/namespace";
}</source></p>

                <p><strong>Class FooBar</strong>. By default, all members are compiled to XML schema with
                 the namespace "http://some/namespace", as defined by the namespace attribute within
                the <code>@XmlType</code> annotation on line 9. The <code>aRequiredElementInAnotherNamespace</code>
                member belongs to the namespace "http://another/namespace", as defined on line 18.
                <br/>
                <source>package se.west.schema;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

@XmlType(namespace = Namespaces.SOME_NAMESPACE,
        propOrder = {"requiredElement", "aRequiredElementInAnotherNamespace",
                "optionalElement", "requiredAttribute", "optionalAttribute"})
@XmlAccessorType(XmlAccessType.FIELD)
public class FooBar {

    @XmlElement(required = true, defaultValue = "requiredElementValue")
    private String requiredElement;

    @XmlElement(namespace = Namespaces.ANOTHER_NAMESPACE, required = true, defaultValue = "requiredElementValue")
    private String aRequiredElementInAnotherNamespace;

    @XmlElement(required = false)
    private String optionalElement;

    @XmlAttribute(required = true)
    private String requiredAttribute;

    @XmlAttribute(required = false)
    private String optionalAttribute;
}</source>
                </p>

                <p><strong>Class FooBaz</strong>. By default, all members are compiled to XML schema with
                 the namespace "http://another/namespace", as defined by the namespace attribute within
                the <code>@XmlType</code> annotation on line 9. The <code>aRequiredElementInYetAnotherNamespace</code>
                member belongs to the namespace "http://yet/another/namespace", as defined on line 18. The
                <code>anOptionalElementInSomeNamespace</code> member belongs to the namespace "http://some/namespace",
                as defined on line 21.
                <br/>

                <source>package se.west.schema;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

@XmlType(namespace = Namespaces.ANOTHER_NAMESPACE,
        propOrder = {"requiredElement", "anOptionalElementInSomeNamespace",
                "aRequiredElementInYetAnotherNamespace", "requiredAttribute", "optionalAttribute"})
@XmlAccessorType(XmlAccessType.FIELD)
public class FooBaz {

    @XmlElement(required = true, defaultValue = "requiredElementValue")
    private String requiredElement;

    @XmlElement(namespace = Namespaces.YET_ANOTHER_NAMESPACE, required = true, defaultValue = "requiredElementValue")
    private String aRequiredElementInYetAnotherNamespace;

    @XmlElement(namespace = Namespaces.SOME_NAMESPACE, required = false)
    private String anOptionalElementInSomeNamespace;

    @XmlAttribute(required = true)
    private String requiredAttribute;

    @XmlAttribute(required = false)
    private String optionalAttribute;
}</source></p>
            </answer>
        </faq>
    </part>
</faqs>
